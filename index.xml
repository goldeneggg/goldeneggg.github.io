<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>horizoon</title>
    <link>https://horizoon.jp/</link>
    <description>Recent content on horizoon</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; Fuminori Sakamoto 2018</copyright>
    <lastBuildDate>Wed, 17 Apr 2019 09:43:00 +0900</lastBuildDate>
    
	<atom:link href="https://horizoon.jp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go: module modeでも躊躇なくcontributeしたければ知っておくと良さそうなこと</title>
      <link>https://horizoon.jp/post/2019/04/17/contributing_with_gomodules/</link>
      <pubDate>Wed, 17 Apr 2019 09:43:00 +0900</pubDate>
      
      <guid>https://horizoon.jp/post/2019/04/17/contributing_with_gomodules/</guid>
      <description>Summary Go1.13がリリースされてGo Modulesのmodule modeがデフォルトになったら、例えばプロジェクトのCONTRIBUTING.mdあたりには何を書いておくと良さそうか？
 「公式ブログ（和訳）を読んでくれ」と書いておく 「公式Wikiを読んでくれ」と書いておく Module-awareモードに最適化した手順を記載しておいて、開発の敷居を下げておく Happy Contributing!!  前提条件 $ go version go version go1.12.4 darwin/amd64 # GO111MODULE=on して、常にModule-awareモードとなる状態で検証 $ export GO111MODULE=on GoプロジェクトにおけるCONTRIBUTING.md githubにプロジェクトを公開する際に、
 ルート docs .github  の3つの内いずれかのディレクトリに contributing* というパターン名（大文字でも可）が付いたファイルを置いておくと、pull-request作成時に「ここにガイドラインがあるよ」と通知してくれるようになります。慣例としてこのファイルは CONTRIBUTING.md という名前で用意されている事が多いです。
このファイルには主に環境構築・テストの実行方法・pull-requestの送り方 などを記載しますが、Goプロジェクトでは「最初に $GOPATH 下にソースを持ってくる」事が前提になっている手順をよく見かけます（自作プロジェクトでもそうしていました）。
Go ModulesのModule-awareモードがデフォルト挙動になるGo1.13以降では、ソースをcloneしてくるディレクトリは何処でも良い＝必ずしも$GOPATH下にソースを持ってくる必要は無くなりますし、依存ライブラリの追加・削除・バージョン変更を行いたい時の流れも変わります。なので、 CONTRIBUTING.mdに書く内容もそれに合わせておくとcontributorに親切なガイドラインを提示できそうです。
引き続き$GOPATHベースでの開発を推奨するプロジェクトもあるかも知れませんし、内容や粒度はプロジェクトの運営方針や想定読者レベルによっても変わるとは思いますが、この記事ではModule-awareモードのレールに乗る前提で整理してみます。
1. セットアップについて書く  cd 任意のディレクトリ git clone foo cd foo make  CONTRIBUTINGの冒頭は「自分のorganizationにforkしてgit clone」と書かれている事が多いですが、clone先のディレクトリは$GOPATHに拘らず何処でも良くなりましたよという事が伝われば、それこそ git clone 任意のディレクトリ と明記しておくだけでも良いと思います。
git clone後にmake（或いは make setup のような名前のターゲット）を叩けば依存ライブラリを取り込んでくれるようなmakeターゲットを用意しておくと初期の敷居を下げられそうです。
$ git clone foo $ cd foo # makeを叩く =&amp;gt; go.</description>
    </item>
    
    <item>
      <title>Goで構造体へのインタフェース埋め込み活用例（aws-sdk-goの事例など）</title>
      <link>https://horizoon.jp/post/2019/03/16/go_embedded_interface/</link>
      <pubDate>Sat, 16 Mar 2019 12:03:00 +0900</pubDate>
      
      <guid>https://horizoon.jp/post/2019/03/16/go_embedded_interface/</guid>
      <description>Summary 構造体へのインタフェース埋め込み活用例 ×2
 一部メソッドを別処理に差し替え 特定のメソッドだけを実装  外部APIアクセスなどを伴う機能のテストをmockで行いたい場合に、gomockのようなmock用ライブラリに依存せずにmock化を実現   type Intf interface { MethodY() MethodZ() } type B struct { Intf // こういう埋め込み } 例1：一部メソッドを別処理に差し替え 無名インタフェースの埋め込み例として本家コードで参考になるのがsort/sort.go のこの実装 です。reverse構造体のコメントにも書いてある通りこうした無名インタフェースを埋め込んだ構造体を利用する事で「一部のメソッドだけ別の実装に差し替える」という事を実現しています。
単純なサンプルコードはこんな感じで、Intfというinterfaceを実装済のAという構造体を ReplaceMethodZ に渡すと、MethodZの挙動だけが異なる別の構造体を取得するという挙動になります。
（同じコードはこちら → https://play.golang.org/p/mh803JB5RSt ）
package main import ( &amp;#34;fmt&amp;#34; ) type Intf interface { MethodY() MethodZ() } type A struct { Str string } func (a *A) MethodY() { fmt.Println(fmt.Sprintf(&amp;#34;%s: MethodY&amp;#34;, a.Str)) } func (a *A) MethodZ() { fmt.</description>
    </item>
    
    <item>
      <title>MySQL8.0 Document Store関連技術まとめ</title>
      <link>https://horizoon.jp/post/2019/03/06/mysql8_3x/</link>
      <pubDate>Wed, 06 Mar 2019 12:15:00 +0900</pubDate>
      
      <guid>https://horizoon.jp/post/2019/03/06/mysql8_3x/</guid>
      <description>Summary  ver 5.7.12 で追加された「3つのX」。ver 8.0からGA  X Protocol X DevAPI X Plugin  X Protocol  アプリケーションがX Pluginと通信するために使われる新プロトコル。MySQLへの（これまで通りの）SQLインターフェース ＋ NoSQLインタフェースの両方をサポートしている  X DevAPI  MySQL用のNoSQLソリューションを開発したり、Document StoreとしてMySQLを使用したりすることを可能にするAPI Connectors  X DevAPIをサポートしている、言語別クライアント C++, Java, Node.js, .NET, Python の各言語向けライブラリが公式に提供されている  MySQL Shell  MySQLサーバへの新しい対話型インタフェースで、Connector同様にX DevAPIをサポートしている 以前からのmysqlコマンドと同じSQLインタフェースに加えて、JavaScript, Pythonでもコンソール上での各種操作が可能。 JSやPythonでmysqlコンソールを操作できる   X Plugin  X Protocolをサーバー側で有効にして、X Protocolを使ってクライアントとの通信を可能にする為のプラグイン Document StoreとしてMySQLを使用する為にはX Pluginが有効化されていなければならない  ver 8.0.11以降はデフォルトで有効化されている   Document Store  「3つのX」を使って、JSON DocumentをNoSQL/DocumentDB likeに取り扱う仕組み    X Protocol 公式 - MySQL :: MySQL Internals Manual :: 15 X Protocol</description>
    </item>
    
    <item>
      <title>conflict-marker.vimを使ってgitのconflictをvimで高速に解消する</title>
      <link>https://horizoon.jp/post/2019/02/26/git_conflict_vim/</link>
      <pubDate>Tue, 26 Feb 2019 14:41:00 +0900</pubDate>
      
      <guid>https://horizoon.jp/post/2019/02/26/git_conflict_vim/</guid>
      <description>Summary 下記手順だとボチボチ速い
 vim conflict対象ファイル qa ]x どの内容を残すかで実行コマンドを変える  HEAD側を残すなら co 非・HEAD側を残すなら ct 両方残すなら cb  q :%norm! @a  前提条件  rhysd/conflict-marker.vim プラグイン をインストールしておく HEAD側を残すか/非・HEAD側を残すか？（あるいは両方消すか？）を個々に判断する必要がなく、ファイル全体で一律どちらを残すかが定まっている  vimで高速conflict解消 conflictなんか起こらない事が理想とはいえそれなりの規模の開発が並行で走っているとなかなかそうもいかず、起こる度に「conflict解消めんどいよね〜」という会話をしてたりします。最近もそういう会話からお互いのやり方を共有し合うという機会があったので、自分がVimで行っている方法を小ネタとして備忘。
前提条件に書いた通り、conflict箇所のどちらを削除するか？がファイル全体で定まっていると判断できたら、
 conflict箇所にジャンプする =&amp;gt; 残したく無い方を削除する =&amp;gt; これをファイル全体で繰り返す  という作業を行えば良く、私が普段使っているNeoVim（Vim）のやり方を晒してみますと下記のような流れの作業になります。
 qa ： レジスタaへのマクロの記録を開始する ]x ： conflict箇所（下方）へジャンプする  conflict-marker.vim プラグイン の機能です。 [x と入力すると逆に上方のconflict箇所へジャンプします  どの内容を残すかで実行コマンドを変える  HEAD側を残すなら co 非・HEAD側を残すなら ct 両方残すなら cb これらも conflict-marker.vim プラグイン の機能です  q ： マクロの記録を終了する :%norm! @a ： ファイル全体を対象にレジスタaに記録したマクロ（＝conflict箇所へジャンプして不要なコードとconflictマーカーを削除）を実行する  :%norm!</description>
    </item>
    
    <item>
      <title>depからgo modulesへの移行と、移行時にTravis CI &amp; GoReleaserでハマる（かもしれない）ポイント</title>
      <link>https://horizoon.jp/post/2019/02/25/dep_to_go_mod/</link>
      <pubDate>Mon, 25 Feb 2019 08:17:54 +0900</pubDate>
      
      <guid>https://horizoon.jp/post/2019/02/25/dep_to_go_mod/</guid>
      <description>Summary  depで管理していた既存のGo製ツールをdepからgo moduleに移行してみたが、移行自体は特にハマりどころも無くスンナリいった go moduleへの移行後に依存パッケージのupgradeを実施、これもスンナリいった Travis CI + GoReleaser で、ビルド成果物をGithub Releasesに登録する作業 ＆ GoアプリのHomeBrewパッケージ作成・公開作業 を自動化しようと試みたが、そのCIが git is currently in a dirty state というコケ方をしてちょっとハマった GoReleaserは本当に便利  前提条件 # goのバージョン $ go version go version go1.11.5 darwin/amd64 切り替え手順 depを使っていたので、go mod init して go build の成功を確認できたらdep関連のファイルを削除する、という手順で完了します（対応例）
# go mod利用時に必要な環境変数、direnvでプロジェクトディレクトリ下のみ適用されるようにしても良さそう $ export GO111MODULE=on # go modulesの初期設定 $ go mod init # go runしてスタンドアロンで実行すれば、そのタイミングでgo.sumファイルが作成される $ go run *.go --help # dep関連ファイルを削除する $ rm Gopkg.toml Gopkg.</description>
    </item>
    
    <item>
      <title>既存のLambda FunctionにLambda Layersを導入し、AWS SAMで管理する（Node.js）</title>
      <link>https://horizoon.jp/post/2019/02/07/lambda_layer_nodejs8/</link>
      <pubDate>Thu, 07 Feb 2019 14:42:54 +0900</pubDate>
      
      <guid>https://horizoon.jp/post/2019/02/07/lambda_layer_nodejs8/</guid>
      <description>Summary  axiosなどのモジュールに依存した既存のNode.js Lambda Functionがある このfunctionで使用しているモジュールをAWS Lambda Layersに移行し、aws-sam-cliでデプロイする 既存functionで個別にnpm installしていたモジュールを削除し、デプロイしたLayerを使用するように変更する Layer移行後も既存functionが sam local invoke コマンドでローカルで実行できる事を確認する Layerを使うように変更した既存functionをデプロイする 移行した結果  既存functionのサイズを半分以下に削減できた 既存functionの実行時間を半分以下に削減できた  AWS SAM 便利  Lambda Layerも便利、だけど、チーム開発でCIの仕組み構築まで考え始めると一工夫必要かも？   前提条件 # aws-cliのバージョン $ aws --version aws-cli/1.16.80 Python/3.7.1 Darwin/18.2.0 botocore/1.12.70 # aws-sam-cliのバージョン $ sam --version SAM CLI, version 0.10.0 既存Functionで使用中のモジュールをLayersに移行する Layer用のプロジェクトディレクトリを作成し、Layer化したいnpmモジュールをインストールします。 ディレクトリの構成は公式ドキュメントの記載 の通り nodejs/node_modules という構成になるようにします。
$ cd &amp;lt;PROJECT_ROOT&amp;gt; $ mkdir nodejs $ cd nodejs $ npm init -y $ npm install [必要なモジュール群] ここまで完了すると、PROJECT_ROOTの下には下記のディレクトリとファイルが作成された状態になります</description>
    </item>
    
    <item>
      <title>MySQL5.7 InnoDB のN-gram全文検索を検証＆サービス導入した</title>
      <link>https://horizoon.jp/post/2018/11/19/mysql_innodb_fts/</link>
      <pubDate>Mon, 19 Nov 2018 03:21:36 +0900</pubDate>
      
      <guid>https://horizoon.jp/post/2018/11/19/mysql_innodb_fts/</guid>
      <description>※ この記事は以前Mediumで公開した記事 の転載です
MySQL5.7・InnoDB・N-gram という環境下で全文検索の挙動やパフォーマンスについて検証を行った。FULLTEXT INDEXは以前はMyISAMでしか利用できなかったが、 5.6.4からInnoDBでのサポートが始まっていた。
InnoDBの全文検索は5.7、特に5.7.6以降でいわゆるCJK（中国語・日本語・韓国語）がN-gramで標準サポートされ始め、 CREATE TABLE文で簡単にパーサーを指定できる構文のサポート、 設定やクエリの組立で考えないといけない事が減った事で導入障壁がかなり下がっている。 ※4.1と5.0でサービス導入経験がある私の個人的な比較感想です。
FULLTEXT INDEXも他のINDEXと同様にデータ更新・削除の際にINDEXのrebuildが走るので更新時の負荷には注意が必要で、FULLTEXT INDEXの場合は「rebuild負荷が列に含まれる単語数に比例する」「rebuildでの断片化が起こりやすい」という固有の注意点もあり、「件数が多い」「FULLTEXT INDEXを貼ったカラムの更新頻度が激しい」という条件が揃ったテーブルへの導入は十分な検証の上で実施した方が良さそう。
下記に書いた検証を経て開発したサービスでも導入してみたが、結論だけ書くと「（当たり前だが）用法用量さえ守れば十分使える。バックエンドのDBがMySQLなら、リッチな全文検索機構を導入する前段階なんかは活用場面としてオススメできる」と感じた。
やること 国税庁が公開している法人番号データを使って検証してみる。データ件数が100万件強程度になるように東京・大阪・海外 の3種類をマージしたデータを使った。用意したデータとテーブルについてはgithubにupしている。charsetをutf8mb4にしているのは、utf8だと登録時にエラーになる文字を含んだ法人が複数存在する為。collationはデフォルトであるuft8mb4_general_ciを使用する。
&amp;gt; show collation like &amp;#39;utf8mb4%&amp;#39; \G; *************************** 1. row *************************** Collation: utf8mb4_general_ci Charset: utf8mb4 Id: 45 Default: Yes Compiled: Yes Sortlen: 1 今回付けたFULLTEXT INDEXは会社名検索・住所検索を想定したものにしている。
-- 法人番号データ投入用テーブルのCREATE文 CREATE TABLE `corporate_nums` ( `id` int NOT NULL AUTO_INCREMENT, `sequence_number` varchar(8) NOT NULL, `corporate_number` char(13) DEFAULT NULL, `process` char(2) DEFAULT NULL, `correct` char(1) DEFAULT NULL, `update_date` char(10) DEFAULT NULL, `change_date` char(10) DEFAULT NULL, `name` varchar(150) DEFAULT NULL, `name_image_id` char(8) DEFAULT NULL, `kind` char(3) DEFAULT NULL, `prefecture_name` varchar(10) DEFAULT NULL, `city_name` varchar(20) DEFAULT NULL, `street_number` varchar(300) DEFAULT NULL, `address_image_id` char(8) DEFAULT NULL, `prefecture_code` char(2) DEFAULT NULL, `city_code` char(3) DEFAULT NULL, `post_code` char(7) DEFAULT NULL, `address_outside` varchar(300) DEFAULT NULL, `address_outside_image_id` char(8) DEFAULT NULL, `close_date` char(10) DEFAULT NULL, `close_cause` char(2) DEFAULT NULL, `successor_corporate_number` char(13) DEFAULT NULL, `change_cause` varchar(500) DEFAULT NULL, `assignment_date` char(10), `latest` char(1) DEFAULT NULL, `en_name` varchar(300) DEFAULT NULL, `en_prefecture_name` varchar(9) DEFAULT NULL, `en_city_name` varchar(600) DEFAULT NULL, `en_address_outside` varchar(600) DEFAULT NULL, PRIMARY KEY (`id`), KEY `cn_i1` (`sequence_number`), KEY `cn_i2` (`corporate_number`), FULLTEXT KEY `cn_fti1` (`name`, `en_name`) WITH PARSER ngram, FULLTEXT KEY `cn_fti2` (`prefecture_name`, `city_name`, `street_number`, `en_prefecture_name`, `en_city_name`) WITH PARSER ngram ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC 件数は↓この通り</description>
    </item>
    
    <item>
      <title>Github Pages &amp; Hugo でブログ公開するまで</title>
      <link>https://horizoon.jp/post/2017/05/21/hugo_github_pages/</link>
      <pubDate>Sun, 21 May 2017 12:54:19 +0900</pubDate>
      
      <guid>https://horizoon.jp/post/2017/05/21/hugo_github_pages/</guid>
      <description>ブログサービスを使わずブログを公開するというのが初めての作業だったので、備忘も兼ねてメモしておく。
Github Pages用のリポジトリを作成 Github Pages にブログを公開するに辺り、まずは こちらの公式の記事を参考に
 pages というリポジトリ - 記事のソースファイル置き場 ACCOUNT名.github.io というリポジトリ - Github Pages 公開用リポジトリ  私の場合 ACCOUNT名 は goldeneggg になる。   という2つのリポジトリを作成した。pagesリポジトリで作成したコンテンツのビルド成果物を goldeneggg.github.io リポジトリに出力→pushして公開する、という流れを想定している。
Hugoの導入 サイトジェネレータの選定だが、Go製の hugo が生成処理が速いという評判だったのと、個人的にGoが好き という理由であまり深くは考えずHugoを使う事にした。
# brew か go get でインストール $ brew install hugo ## Or $ go get -u -v github.com/spf13/hugo Hugoの初期設定  最初に作成した 記事のソースファイル置き場 用のリポジトリを git clone する cloneしたディレクトリにcdし、hugo new site . する。これで雛形となるディレクトリ群が生成される  $ git clone git@github.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://horizoon.jp/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://horizoon.jp/about/</guid>
      <description>I&amp;rsquo;m a web developer and engineer manager, especially good at server side engineering.
I also like the technology itself, but I like the job of assembling customer&amp;rsquo;s tasks into concrete system requirements and I&amp;rsquo;m good at it. I have plenty of knowledge on fintech.
And I&amp;rsquo;m a backpacker. I love all south east asian countries!
Contact Please send a mail here.
My Resume My resume and skillsets are here (Github Gist).</description>
    </item>
    
    <item>
      <title>Projects</title>
      <link>https://horizoon.jp/projects/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://horizoon.jp/projects/</guid>
      <description>Tools &amp;amp; Libraries   lsec2 - Go: List view of aws ec2 instances.   gat - Go: Concatnating and printing file to various services.   And others&amp;hellip;  Services Coming soon&amp;hellip;</description>
    </item>
    
  </channel>
</rss>