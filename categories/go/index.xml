<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on horizoon</title>
    <link>https://horizoon.jp/categories/go/</link>
    <description>Recent content in Go on horizoon</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; Fuminori Sakamoto 2018</copyright>
    <lastBuildDate>Wed, 17 Apr 2019 09:43:00 +0900</lastBuildDate>
    
	<atom:link href="https://horizoon.jp/categories/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go: module modeでも躊躇なくcontributeしたければ知っておくと良さそうなこと</title>
      <link>https://horizoon.jp/post/2019/04/17/contributing_with_gomodules/</link>
      <pubDate>Wed, 17 Apr 2019 09:43:00 +0900</pubDate>
      
      <guid>https://horizoon.jp/post/2019/04/17/contributing_with_gomodules/</guid>
      <description>Summary Go1.13がリリースされてGo Modulesのmodule modeがデフォルトになったら、例えばプロジェクトのCONTRIBUTING.mdあたりには何を書いておくと良さそうか？
 「公式ブログ（和訳）を読んでくれ」と書いておく 「公式Wikiを読んでくれ」と書いておく Module-awareモードに最適化した手順を記載しておいて、開発の敷居を下げておく Happy Contributing!!  前提条件 $ go version go version go1.12.4 darwin/amd64 # GO111MODULE=on して、常にModule-awareモードとなる状態で検証 $ export GO111MODULE=on GoプロジェクトにおけるCONTRIBUTING.md githubにプロジェクトを公開する際に、
 ルート docs .github  の3つの内いずれかのディレクトリに contributing* というパターン名（大文字でも可）が付いたファイルを置いておくと、pull-request作成時に「ここにガイドラインがあるよ」と通知してくれるようになります。慣例としてこのファイルは CONTRIBUTING.md という名前で用意されている事が多いです。
このファイルには主に環境構築・テストの実行方法・pull-requestの送り方 などを記載しますが、Goプロジェクトでは「最初に $GOPATH 下にソースを持ってくる」事が前提になっている手順をよく見かけます（自作プロジェクトでもそうしていました）。
Go ModulesのModule-awareモードがデフォルト挙動になるGo1.13以降では、ソースをcloneしてくるディレクトリは何処でも良い＝必ずしも$GOPATH下にソースを持ってくる必要は無くなりますし、依存ライブラリの追加・削除・バージョン変更を行いたい時の流れも変わります。なので、 CONTRIBUTING.mdに書く内容もそれに合わせておくとcontributorに親切なガイドラインを提示できそうです。
引き続き$GOPATHベースでの開発を推奨するプロジェクトもあるかも知れませんし、内容や粒度はプロジェクトの運営方針や想定読者レベルによっても変わるとは思いますが、この記事ではModule-awareモードのレールに乗る前提で整理してみます。
1. セットアップについて書く  cd 任意のディレクトリ git clone foo cd foo make  CONTRIBUTINGの冒頭は「自分のorganizationにforkしてgit clone」と書かれている事が多いですが、clone先のディレクトリは$GOPATHに拘らず何処でも良くなりましたよという事が伝われば、それこそ git clone 任意のディレクトリ と明記しておくだけでも良いと思います。
git clone後にmake（或いは make setup のような名前のターゲット）を叩けば依存ライブラリを取り込んでくれるようなmakeターゲットを用意しておくと初期の敷居を下げられそうです。
$ git clone foo $ cd foo # makeを叩く =&amp;gt; go.</description>
    </item>
    
    <item>
      <title>Goで構造体へのインタフェース埋め込み活用例（aws-sdk-goの事例など）</title>
      <link>https://horizoon.jp/post/2019/03/16/go_embedded_interface/</link>
      <pubDate>Sat, 16 Mar 2019 12:03:00 +0900</pubDate>
      
      <guid>https://horizoon.jp/post/2019/03/16/go_embedded_interface/</guid>
      <description>Summary 構造体へのインタフェース埋め込み活用例 ×2
 一部メソッドを別処理に差し替え 特定のメソッドだけを実装  外部APIアクセスなどを伴う機能のテストをmockで行いたい場合に、gomockのようなmock用ライブラリに依存せずにmock化を実現   type Intf interface { MethodY() MethodZ() } type B struct { Intf // こういう埋め込み } 例1：一部メソッドを別処理に差し替え 無名インタフェースの埋め込み例として本家コードで参考になるのがsort/sort.go のこの実装 です。reverse構造体のコメントにも書いてある通りこうした無名インタフェースを埋め込んだ構造体を利用する事で「一部のメソッドだけ別の実装に差し替える」という事を実現しています。
単純なサンプルコードはこんな感じで、Intfというinterfaceを実装済のAという構造体を ReplaceMethodZ に渡すと、MethodZの挙動だけが異なる別の構造体を取得するという挙動になります。
（同じコードはこちら → https://play.golang.org/p/mh803JB5RSt ）
package main import ( &amp;#34;fmt&amp;#34; ) type Intf interface { MethodY() MethodZ() } type A struct { Str string } func (a *A) MethodY() { fmt.Println(fmt.Sprintf(&amp;#34;%s: MethodY&amp;#34;, a.Str)) } func (a *A) MethodZ() { fmt.</description>
    </item>
    
    <item>
      <title>depからgo modulesへの移行と、移行時にTravis CI &amp; GoReleaserでハマる（かもしれない）ポイント</title>
      <link>https://horizoon.jp/post/2019/02/25/dep_to_go_mod/</link>
      <pubDate>Mon, 25 Feb 2019 08:17:54 +0900</pubDate>
      
      <guid>https://horizoon.jp/post/2019/02/25/dep_to_go_mod/</guid>
      <description>Summary  depで管理していた既存のGo製ツールをdepからgo moduleに移行してみたが、移行自体は特にハマりどころも無くスンナリいった go moduleへの移行後に依存パッケージのupgradeを実施、これもスンナリいった Travis CI + GoReleaser で、ビルド成果物をGithub Releasesに登録する作業 ＆ GoアプリのHomeBrewパッケージ作成・公開作業 を自動化しようと試みたが、そのCIが git is currently in a dirty state というコケ方をしてちょっとハマった GoReleaserは本当に便利  前提条件 # goのバージョン $ go version go version go1.11.5 darwin/amd64 切り替え手順 depを使っていたので、go mod init して go build の成功を確認できたらdep関連のファイルを削除する、という手順で完了します（対応例）
# go mod利用時に必要な環境変数、direnvでプロジェクトディレクトリ下のみ適用されるようにしても良さそう $ export GO111MODULE=on # go modulesの初期設定 $ go mod init # go runしてスタンドアロンで実行すれば、そのタイミングでgo.sumファイルが作成される $ go run *.go --help # dep関連ファイルを削除する $ rm Gopkg.toml Gopkg.</description>
    </item>
    
  </channel>
</rss>